/**
 * Actividad: Programaci칩n din치mica, backtracking, y ramificaci칩n y poda
 * Ejercicio 2
 * Hecho por el Alumno:
 * Juan Pablo Zambrano Barajas A01636420
 * TC2038 con el Dr. Omar Mendoza
 * Creado el 24/09/2023, ultima modificacion 26/09/2023
 * Compilar:
 *   g++ -std=c++17 -Wall -O3 *.cpp -o main
 * Ejecutar:
 *   ./main
 */
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cctype> 
#include <map>
#include <algorithm>
#include <cstdint>

using namespace std;

const int prime = 97;
const long long largeModPrime = 1e9 + 9; //another prime num ber
//code generated by chatg
uint32_t murmur3Hash(const string &word) {
  const uint32_t seed = 0; // Seed value

  uint32_t hashValue = seed;
  const uint32_t c1 = 0xcc9e2d51;
  const uint32_t c2 = 0x1b873593;
  const uint32_t r1 = 15;
  const uint32_t r2 = 13;
  const uint32_t m = 5;
  const uint32_t n = 0xe6546b64;

  for (size_t i = 0; i < word.length(); ++i) {
    uint32_t k = word[i];
    k *= c1;
    k = (k << r1) | (k >> (32 - r1));
    k *= c2;

    hashValue ^= k;
    hashValue = ((hashValue << r2) | (hashValue >> (32 - r2))) * m + n;
  }

  hashValue ^= word.length();
  hashValue ^= hashValue >> 16;
  hashValue *= 0x85ebca6b;
  hashValue ^= hashValue >> 13;
  hashValue *= 0xc2b2ae35;
  hashValue ^= hashValue >> 16;

  return hashValue;
}

map<long long, pair<string, int>> countOccurrences(vector<string>& words){
    map<long long, pair<string, int>> wordOcurrences;
    for(string& word: words){
        long long hash = murmur3Hash(word);
        if(wordOcurrences.find(hash) != wordOcurrences.end()){
            wordOcurrences[hash].second++;
        }else{
            wordOcurrences[hash] = make_pair(word, 1);
        }
    }
    return wordOcurrences;
}
bool isAlphaCharacter(char c) {
    return isalpha(static_cast<unsigned char>(c));
}

// Function to read a text file and insert words into a vector
vector<string> fillVectorWithWords(const string& filename) {
    ifstream inputFile(filename);
    vector<string> words;

    if (!inputFile.is_open()) {
        cerr << "Error abriendo el archivo, revisa la ruta o el nombre" << endl;
        return words; // Return an empty vector in case of an error
    }
    string line;
    while (getline(inputFile, line)) {
        istringstream iss(line);
        string word;
        while (iss >> word) {
            // Process the word to keep only alphabetic characters
            string cleanedWord;
            for (char c : word) {
                if (isAlphaCharacter(c)) {
                    cleanedWord.push_back(c);
                }
            }
            if (!cleanedWord.empty()) {
                words.push_back(cleanedWord);
            }
        }
    }

    inputFile.close();
    return words;
}

int main() {

    vector<string> words = fillVectorWithWords("romeo_and_juliet.txt");
    map<long long, pair<string, int>> wo = countOccurrences(words);
    
    vector<pair<long long, pair<string, int>>> orderedOccurrences(wo.begin(), wo.end());

    // Ordenar el vector en funci칩n del valor del numero
    sort(orderedOccurrences.begin(), orderedOccurrences.end(), [](const auto& a, const auto& b) {
        return a.second.second > b.second.second; // Ordenar
    });
    int numberIteration = 1;
    for (auto& entry : orderedOccurrences) {
        long long hash = entry.first;
        string word = entry.second.first;
        int count = entry.second.second;

        cout << numberIteration <<". Hash: " << hash << ", Word: " << word << ", Count: " << count << endl;
        numberIteration++;
        if(numberIteration>=21){
            break;
        }
    }
    return 0;
}
